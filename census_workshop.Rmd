---
title: "Working with United States Census Data Using tidycensus"
output: html_document
---


```{r, echo=FALSE,results=FALSE,message=FALSE}
library(tidycensus)
library(tidyverse)
library(knitr)
library(tmap)
library(sf)
Sys.getenv("CENSUS_API_KEY")
```

```{r, eval=FALSE}
library(tidycensus)
library(tidyverse)
census_api_key("YOUR API KEY GOES HERE")
```

## Inspect variables for Decennial Census
```{r view variables}
decennial_variables<-load_variables(2010,"sf1")
View(decennial_variables)
```

```{r,echo=FALSE}
kable(head(decennial_variables))
```


## Calling and Manipulating Data using tidycensus and dplyr: Basics

### Calling and Viewing Data

Let's find out the population, by state, in 2010: 

```{r, message=FALSE}
state_population_2010<-get_decennial(geography = "state", 
                                     variables = "P001001", 
                                     geometry=TRUE,
                                     shift_geo = TRUE,
                                     year = 2010)
View(state_population_2010)
```


```{r,echo=FALSE}
kable(head(state_population_2010))
```

We can adjust the geography and year parameters; let's say we want the population distribution 
across CO counties in the year 2010:

```{r,message=FALSE}
CO_county_population_2010<-get_decennial(geography = "county", 
                                         state="CO",
                                         variables = "P001001", 
                                         year = 2010)
View(CO_county_population_2010)
```

```{r,echo=FALSE}
kable(head(CO_county_population_2010))
```

### Cleaning and Manipulating Data Using dplyr

Let's clean up the table by removing the "variable" column, and renaming the "value" column as "Population", which we can do using functions from the "dplyr" package. 

```{r, message=FALSE}
CO_county_population_2010<-get_decennial(geography = "county", 
                                         state="CO",
                                         variables = "P001001", 
                                         year = 2000) %>% 
                           mutate(variable=NULL) %>% 
                           rename(population=value)

View(CO_county_population_2010)
```

```{r,echo=FALSE}
kable(head(CO_county_population_2010))
```

It's also possible to call multiple variables into a single table. To see this, let's add a field/column containing the rural population in each state in 2010 (as well as the total population in that year), and order the dataset in descending order with respect to the rural population (such that the state with the largest rural population will appear as the first record in the dataset):

```{r,message=FALSE,results=FALSE}
state_pop_ruralpop_2010<-get_decennial(geography = "state", 
                                          variables = c("P001001", "P002005"),
                                          output="wide",
                                          year = 2010) %>% 
                         rename(total_population=P001001, rural_population=P002005) %>% 
                         arrange(desc(rural_population))

state_pop_ruralpop_2010

```

```{r,echo=FALSE}
kable(head(state_pop_ruralpop_2010))
```

Let's generate a new variable based on the variables we already have in the dataset. This variable will measure the percentage of each state's population that are rural residents (calculated by dividing the rural population by the total population, and multiplying by 100). We'll call this variable "rural_pct". We'll also resort the dataset, so that it's sorted in descending order with respect to the new "rural_pct" variable, instead of the actual number of rural residents:


```{r}
state_pop_ruralpop_2010<-
  state_pop_ruralpop_2010 %>% mutate(rural_pct=(rural_population/total_population)*100) %>% 
                              arrange(desc(rural_pct))
  
View(state_pop_ruralpop_2010)
```

```{r,echo=FALSE}
kable(head(state_pop_ruralpop_2010))
```

The dplyr package also makes it easy to filter datasets based on specific criteria, which we can then assign to a new object. For example, let's say that we want to generate a new dataset that only includes states whose rural populations are greater than 40% of their overall populations. We'll assign this new dataset to an object called "rural_pct_over40":

```{r}
rural_pct_over40<-state_pop_ruralpop_2010 %>% filter(rural_pct>40)
View(rural_pct_over40)
```

```{r,echo=FALSE}
kable(rural_pct_over40)
```

### Student Exercise

Create a dataset of Colorado counties that had a rural population that exceeded 50% of the county's overall population in 2010, and sort the dataset in descending order with respect to the field containing information on the percentage of the county's rural resident's. Your final dataset should look something like this:

```{r,echo=FALSE,message=FALSE}
rural_pct_over50_CO2010<-get_decennial(geography = "county",
                                       state="CO",
                                       variables = c("P001001", "P002005"),
                                       output="wide",
                                       year = 2010) %>% 
                       mutate(variable=NULL) %>% 
                       rename(total_population=P001001, rural_population=P002005) %>% 
                       mutate(rural_pct=(rural_population/total_population)*100) %>% 
                       filter(rural_pct>50) %>% 
                       arrange(desc(rural_pct))

kable(rural_pct_over50_CO2010)
```


##More advanced data wrangling

```{r}

```

##Iteration, Temporal Dynamics, and Exploratory Visualization 

Let's 

```{r}
my_years<-c(2000,2010)
population_rural_2000_2010<-map(
  my_years,
  ~(get_decennial(geography = "state", 
                  variables = c("P001001", "P002005"),
                  output="wide",
                  year =.)) %>% 
    mutate(rural_pct=(P002005/P001001)*100) %>% 
    arrange(NAME)
)

names(population_rural_2000_2010)<-my_years

rural_change<-full_join(population_rural_2000_2010[["2000"]],
                        population_rural_2000_2010[["2010"]],by="NAME") %>%  
              mutate(rural_pct_change=rural_pct.y-rural_pct.x) %>% 
              select(NAME,rural_pct_change)
rural_change
```

```{r,fig.width=9,fig.height=7}
basegraph<-rural_change %>%
  ggplot(aes(x = reorder(NAME,rural_pct_change), y=rural_pct_change)) + 
  geom_col()+
  coord_flip()

basegraph+labs(title="Rural Depopulation", x="State Name", y="Pct Change in Rural Population")+
  theme(plot.title=element_text(hjust=0.5))
```


```{r}
rural_depop_tomap<-full_join(state_population_2010,rural_change,by="NAME")

foundational_map<-tm_shape(rural_depop_tomap)+
  tm_polygons(col="rural_pct_change", n=6,style="jenks",palette="BuGn", midpoint=TRUE)

foundational_map
```

```{r}
##custom breaks and title
revised_map<-tm_shape(rural_depop_tomap)+
  tm_polygons(col="rural_pct_change", breaks=c(-6,-4,-2, 0, 1, 2),palette="YlGnBu", midpoint=TRUE)+
  tm_layout(frame=FALSE, main.title="Percentage Point Change\nin Rural Population, By State",  
              main.title.position="left", legend.outside=TRUE)

revised_map
```

## Student Visualization Practice 

Practice visualizing Census by doing ONE of the following: 1) make a map (using the tmap package) that shows county-level variation in the median age across the state of Colorado or 2) make a visualization (using the ggplot package) of state-level variation in the median age across the entire United States.

### Option 1 Code 

```{r, warning=FALSE,message=FALSE, results=FALSE}
median_age_CO<- get_decennial(geography = "county",
                              state="CO",
                              variables = "P013001", 
                              year = 2010,
                              geometry = TRUE) %>% 
                rename(median_age=value) %>% 
                relocate(NAME)
```

```{r, message=FALSE,warning=FALSE}
median_age_CO_map<-tm_shape(median_age_CO)+
                   tm_polygons(col="median_age",breaks=c(30,35,40,45,50),palette="YlGnBu", midpoint=TRUE)+
                   tm_layout(frame=FALSE, main.title="Median Age by County,\nColorado",  
                   main.title.position="left", legend.outside=TRUE)

median_age_CO_map
```

Making a Web Map

```{r, message=FALSE, warning=FALSE}

tmap_mode("view")
median_age_CO_map
```


### Option 2 Code 

```{r,fig.width=9,fig.height=7}
median_age_CO_visualization<-
  median_age_CO %>%
  ggplot(aes(x = median_age, y = reorder(NAME, median_age))) + 
  geom_point()+
  labs(title="Median Age by County, CO", x="Median Age", y="County Name")+
  theme(plot.title=element_text(hjust=0.5))

median_age_CO_visualization
```

```{r,fig.width=9,fig.height=7}
median_age_CO_cleaned<-median_age_CO %>% 
                       mutate(County_Name=str_remove_all(NAME,"Colorado|,|County"))

median_age_CO_cleaned_visualization<-
  median_age_CO_cleaned %>%
  ggplot(aes(x = median_age, y = reorder(County_Name, median_age))) + 
  geom_point()+
  labs(title="Median Age by County, CO", x="Median Age", y="County")+
  theme(plot.title=element_text(hjust=0.5))

median_age_CO_cleaned_visualization
```

## American Community Survey 

### Calling ACS Data

To inspect the variable list for the ACS, use the "load variables" function. Let's say we want to work with the 5-year ACS ending in 2019: 

```{r}
ACS_5_2019<-load_variables(2019,"acs5")
View(ACS_5_2019)
```

```{r,echo=FALSE}
kable(head(ACS_5_2019))
```

Let's issue a call to the API and generate a table that gives us the median-income of the United States by county. We may want to eventually have the option of mapping this data, so we'll set the geometry parameter equal to TRUE. Note that when using the "get_acs" function call, the default setting will return data from the 5-year ACS that terminates in the specified year (i.e. if the year parameter is set to 2019, the function will return the 2015-2019 ACS). If we want to call the 1 year or 3 year ACS, the "survey" argument of the "get_acs" function could be set to "acs1" or "acs3", depending on which survey we are interested in calling. 

```{r, message=FALSE, warning=FALSE}
median_income<-get_acs(geography="county",
                       variables="B19013_001",
                       year=2019,
                       geometry=TRUE,
                       shift_geo=TRUE) %>% 
              rename(median_income=estimate) %>% 
              arrange(desc(median_income))
               
View(median_income)
```

```{r,echo=FALSE}
kable(head(median_income))
```

### Manipulating and Visualizing ACS Data: dplyr's "group_by" and "slice" functions, and visualizing uncertainty using ggplot

Let's say that we want to generate a table that contains the highest median-income county for each state. To do so, we will use dplyr's "group_by" and "slice" functions, after separating out the "Name" field in the existing table (which is in the form "County Name, State") into separate "County" and "State" fields:

```{r, results=FALSE}
highest_income_counties<-median_income %>% 
  separate(NAME,c("County","State"),sep=",") %>% 
  group_by(State) %>% 
  arrange(desc(median_income)) %>% 
  slice(1) %>% 
  unite(NAME, c("County","State"), remove=FALSE, sep=",")

View(highest_income_counties)
```

```{r}
kable(highest_income_counties) 
```

If we want to visualize this information, we can incorporate the MOE for these estimates into the visualization, so that we can convey the uncertainty surrounding these median income estimates.

```{r,fig.width=9,fig.height=7}
highest_income_counties_viz<-highest_income_counties %>% 
                             ggplot(aes(x=median_income,y=reorder(NAME, median_income)))+
                             geom_errorbarh(aes(xmin = median_income - moe, xmax = median_income + moe)) +
                             geom_point(color = "red", size = 3)+
                                        labs(title="County with Highest Median Income, by State",
                                        y="",
                                        x="Median Income Estimate from ACS (bars indicate margin of error)")
highest_income_counties_viz                                    
```



student exercise where they do same for the lowest

correlation between income and election results

correlation between health insurance and covid 




## across the state of Colorado in the year 2010 OR 2) A visualization of county-level 


## Additional Work with Dplyr and Visualization

##county median age map? 


## Appendix 

```{r}
my_years<-c(2000,2010)
population_rural_2000_2010<-map(
  my_years,
  ~(get_decennial(geography = "state", 
                 variables = c("P001001", "P002005"),
                 output="wide",
                 year =.)) %>% 
      mutate(rural_pct=(P002005/P001001)*100) %>% 
      arrange(NAME)
  )

names(population_rural_2000_2010)<-my_years

joined_ds<-full_join(population_rural_2000_2010[["2000"]],population_rural_2000_2010[["2010"]],by="NAME") %>% 
           mutate(pct_change=rural_pct.y-rural_pct.x) %>% 
           select(NAME,pct_change)
joined_ds
```

