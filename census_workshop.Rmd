---
title: "Working with United States Census Data Using tidycensus"
output: html_document
---


```{r, echo=FALSE,results=FALSE,message=FALSE}
library(tidycensus)
library(tidyverse)
library(knitr)
library(tmap)
Sys.getenv("CENSUS_API_KEY")
```

```{r, eval=FALSE}
library(tidycensus)
library(tidyverse)
census_api_key("YOUR API KEY GOES HERE")
```

## Inspect variables for Decennial Census
```{r view variables}
decennial_variables<-load_variables(2010,"sf1")
View(decennial_variables)
```

```{r,echo=FALSE}
kable(head(decennial_variables))
```


## Calling and Manipulating Data using tidycensus and dplyr: Basics

### Calling and Viewing Data

Let's find out the population, by state, in 2010: 

```{r, message=FALSE}
state_population_2010<-get_decennial(geography = "state", 
                                     variables = "P001001", 
                                     geometry=TRUE,
                                     shift_geo = TRUE,
                                     year = 2010)
View(state_population_2010)
```


```{r,echo=FALSE}
kable(head(state_population_2010))
```

We can adjust the geography and year parameters; let's say we want the population distribution 
across CO counties in the year 2010:

```{r,message=FALSE}
CO_county_population_2010<-get_decennial(geography = "county", 
                                         state="CO",
                                         variables = "P001001", 
                                         year = 2010)
View(CO_county_population_2010)
```

```{r,echo=FALSE}
kable(head(CO_county_population_2010))
```

### Cleaning and Manipulating Data Using dplyr

Let's clean up the table by removing the "variable" column, and renaming the "value" column as "Population", which we can do using functions from the "dplyr" package. 

```{r, message=FALSE}
CO_county_population_2010<-get_decennial(geography = "county", 
                                         state="CO",
                                         variables = "P001001", 
                                         year = 2000) %>% 
                           mutate(variable=NULL) %>% 
                           rename(population=value)

View(CO_county_population_2010)
```

```{r,echo=FALSE}
kable(head(CO_county_population_2010))
```

It's also possible to call multiple variables into a single table. To see this, let's add a field/column containing the rural population in each state in 2010 (as well as the total population in that year), and order the dataset in descending order with respect to the rural population (such that the state with the largest rural population will appear as the first record in the dataset):

```{r,message=FALSE,results=FALSE}
state_pop_ruralpop_2010<-get_decennial(geography = "state", 
                                          variables = c("P001001", "P002005"),
                                          output="wide",
                                          year = 2010) %>% 
                         rename(total_population=P001001, rural_population=P002005) %>% 
                         arrange(desc(rural_population))

state_pop_ruralpop_2010

```

```{r,echo=FALSE}
kable(head(state_pop_ruralpop_2010))
```

Let's generate a new variable based on the variables we already have in the dataset. This variable will measure the percentage of each state's population that are rural residents (calculated by dividing the rural population by the total population, and multiplying by 100). We'll call this variable "rural_pct". We'll also resort the dataset, so that it's sorted in descending order with respect to the new "rural_pct" variable, instead of the actual number of rural residents:


```{r}
state_pop_ruralpop_2010<-
  state_pop_ruralpop_2010 %>% mutate(rural_pct=(rural_population/total_population)*100) %>% 
                              arrange(desc(rural_pct))
  
View(state_pop_ruralpop_2010)
```

```{r,echo=FALSE}
kable(head(state_pop_ruralpop_2010))
```

The dplyr package also makes it easy to filter datasets based on specific criteria, which we can then assign to a new object. For example, let's say that we want to generate a new dataset that only includes states whose rural populations are greater than 40% of their overall populations. We'll assign this new dataset to an object called "rural_pct_over40":

```{r}
rural_pct_over40<-state_pop_ruralpop_2010 %>% filter(rural_pct>40)
View(rural_pct_over40)
```

```{r,echo=FALSE}
kable(rural_pct_over40)
```

### Student Exercise

Create a dataset of Colorado counties that had a rural population that exceeded 50% of the county's overall population in 2010, and sort the dataset in descending order with respect to the field containing information on the percentage of the county's rural resident's. Your final dataset should look something like this:

```{r,echo=FALSE,message=FALSE}
rural_pct_over50_CO2010<-get_decennial(geography = "county",
                                       state="CO",
                                       variables = c("P001001", "P002005"),
                                       output="wide",
                                       year = 2010) %>% 
                       mutate(variable=NULL) %>% 
                       rename(total_population=P001001, rural_population=P002005) %>% 
                       mutate(rural_pct=(rural_population/total_population)*100) %>% 
                       filter(rural_pct>50) %>% 
                       arrange(desc(rural_pct))

kable(rural_pct_over50_CO2010)
```


##More advanced data wrangling

```{r}

```

##Iteration, Temporal Dynamics, and Exploratory Visualization 

Let's 

```{r}
my_years<-c(2000,2010)
population_rural_2000_2010<-map(
  my_years,
  ~(get_decennial(geography = "state", 
                  variables = c("P001001", "P002005"),
                  output="wide",
                  year =.)) %>% 
    mutate(rural_pct=(P002005/P001001)*100) %>% 
    arrange(NAME)
)

names(population_rural_2000_2010)<-my_years

rural_change<-full_join(population_rural_2000_2010[["2000"]],
                        population_rural_2000_2010[["2010"]],by="NAME") %>%  
              mutate(rural_pct_change=rural_pct.y-rural_pct.x) %>% 
              select(NAME,rural_pct_change)
rural_change
```

```{r,fig.width=9,fig.height=7}
basegraph<-rural_change %>%
  ggplot(aes(x = reorder(NAME,rural_pct_change), y=rural_pct_change)) + 
  geom_col()+
  coord_flip()

basegraph+labs(title="Rural Depopulation", x="State Name", y="Pct Change in Rural Population")+
  theme(plot.title=element_text(hjust=0.5))
```


```{r}
rural_depop_tomap<-full_join(state_population_2010,rural_change,by="NAME")

foundational_map<-tm_shape(rural_depop_tomap)+
  tm_polygons(col="rural_pct_change", n=6,style="jenks",palette="BuGn", midpoint=TRUE)

foundational_map
```

```{r}
##custom breaks and title
revised_map<-tm_shape(rural_depop_tomap)+
  tm_polygons(col="rural_pct_change", breaks=c(-6,-4,-2, 0, 1, 2),palette="YlGnBu", midpoint=TRUE)+
  tm_layout(frame=FALSE, main.title="Percentage Point Change\nin Rural Population, By State",  
              main.title.position="left", legend.outside=TRUE)

revised_map
```

## Additional Work with Dplyr and Visualization




## Appendix 

```{r}
my_years<-c(2000,2010)
population_rural_2000_2010<-map(
  my_years,
  ~(get_decennial(geography = "state", 
                 variables = c("P001001", "P002005"),
                 output="wide",
                 year =.)) %>% 
      mutate(rural_pct=(P002005/P001001)*100) %>% 
      arrange(NAME)
  )

names(population_rural_2000_2010)<-my_years

joined_ds<-full_join(population_rural_2000_2010[["2000"]],population_rural_2000_2010[["2010"]],by="NAME") %>% 
           mutate(pct_change=rural_pct.y-rural_pct.x) %>% 
           select(NAME,pct_change)
joined_ds
```

